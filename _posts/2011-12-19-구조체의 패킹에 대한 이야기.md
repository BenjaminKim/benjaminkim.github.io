---
layout: post
categories: essay
image: https://t1.daumcdn.net/cfile/tistory/134FE3354EEDF90B1D
---
MSDN에 따르면 구조체의 [디폴트 패킹 값은 8](https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-6.0/aa273913(v=vs.60)?redirectedfrom=MSDN)이다.  
간혹 32비트 운영체제에서는 4바이트이고 64비트 운영체제에서는 8바이트라고 주장하는 사람들도 있는데 디폴트 패킹 크기는 컴파일러가 결정하지 운영체제가 결정하는 것이 아니다.  
MSVC에서 디폴트 패킹을 8바이트로 정한 이유는(32비트 운영체제에서 조차) 기본 타입 중 가장 큰 타입이 8바이트이기 때문이다.  
만약 이후에 16바이트 포인터나 INT128 같은 타입을 기본 타입으로써 사용하는 날이 온다면 그 때는 디폴트 패킹 값도 16바이트로 변경될 것으로 예상한다.

여기에 패킹을 잘 이해하고 있는지 알아보기 위한 좋은 질문이 있다.

```c++
strcut X
{
  char c1;
  char c2;
  char c3;
  char c4;
  char c5;
  char c6;
  char c7;
};

struct Y
{
  char c;
  double d;
  int i;
};
```
디폴트 패킹 값인 8을 사용한다고 할 때 구조체 X와 Y의 크기는 각각 얼마일까?  
잠시 생각해보고 답을 확인해보도록 하자.

.  
.  
.  
.  
.  
.  
.  
.

답은 7 bytes 와 24 bytes이다. 틀린 사람들은 이 포스트를 계속 읽어볼 필요가 있다.

Y 구조체의 레이아웃은 다음처럼 된다.

```c++
struct Y
{
  char c;
  // pad[7]
  double d;
  int i;
  // pad[4]
};
```

## 뭐야, 왜 이리 어려워?

구조체의 멤버들은 자신의 크기의 배수로 정렬되는 것이 좋다.  
`char`는 1의 배수, `short`은 2의 배수, `int`는 4의 배수, `double`은 8의 배수의 메모리 번지 주소에 위치하고 있을 때 우리는 해당 데이터가 정렬되어 있다고 말한다.  
x86 아키텍쳐에서 윈도 애플리케이션을 만들 경우에는 정렬이 되어있지 않을 때 CPU가 메모리에 다시 접근하려고 시도하면서 성능이 떨어지게 된다.  
다른 아키텍쳐에서는 애플리케이션이 크래시가 나거나 따로 예외 핸들링을 해주어야 할 수도 있다.

그래서 컴파일러는 데이터를 정렬시키기 위해서 구조체의 적당한 위치에 패딩을 집어넣는다.  
조금 생각해보면 위 Y구조체에 마지막 4바이트 패딩은 필요가 없을 것 같다.  
중간에 넣은 7바이트 패딩으로 인해 3개의 필드가 모두 잘 정렬이 된 것 같은데 말이다.
뒷 부분에 4바이트 패딩을 넣은 이유는 구조체가 배열에서 사용될 때 구조체의 멤버들이 메모리의 정렬된 위치에 올라가도록 하고 싶기 때문이다.  
뒷 부분에 패딩을 넣지 않았으면 int나 double 타입이 자신의 타입에 맞게 정렬된 주소에 올라가지 못했을 것이다.

다음 Z구조체를 보자. 위의 Y구조체에서 `double`과 `int`의 위치만 바꾸었다.  
-위치만 바꾸었는데 패딩이 Y구조체와 다르게 들어가는 것에 대해서도 유심히 살펴 보아야 한다.

```c++
struct Z
{
    char c;
    // pad[3]
    int i;
    double d;
};

int _tmain(int argc, _TCHAR* argv[])
{
    // 다음 코드를 사용해서 어떻게 padding이 들어가 있는지 쉽게 확인해볼 수 있다.
    printf("position c:%d\n", FIELD_OFFSET(Z, c));
    printf("position i:%d\n", FIELD_OFFSET(Z, i));
    printf("position d:%d\n", FIELD_OFFSET(Z, d));
    printf("Total size:%d\n", sizeof(Z));
}
```

직접 코드를 실행시켜보는 것도 좋고, 아래 그림을 보고 이해해도 좋다.  
이 구조체가 배열에서 사용될 때에는 아래와 같은 레이아웃을 갖게 될 것이다.

![](https://t1.daumcdn.net/cfile/tistory/134FE3354EEDF90B1D)

`char`는 1의 배수에, `int`는 4의 배수에, `double`은 8의 배수에 정렬되어져 올라가 있는 것을 주목하라.  
진한 파란색으로 표시된 3바이트 패딩이 있기 때문에 가능한 일이다.

맨 처음 문제에서 X구조체의 크기가 8 bytes가 아니라 7 bytes인 이유는 모든 멤버가 char이기 때문이다.  
`char`는 1의 배수인 어느 주소에나 올라가도 되므로 padding을 집어 넣지 않아도 모든 멤버가 항상 자신이 원하는 주소에 올라가게 된다.  
Y구조체가 Z구조체와 멤버 위치만 바꾸었는데 다른 레이아웃을 가지고 있는 이유도 그림을 그리면서 확인해보면 이해할 수 있을 것이다.

8로 패킹한다는 것은 구조체의 크기를 8의 배수로 맞추겠다는 것이 아니라, 크기가 8보다 큰 멤버가 있을 때는 정렬을 포기한다는 것을 뜻한다.  
즉, 크기가 8보다 작은 타입에 대해서만 정렬하려고 시도하며, 이것은 다른 말로, 변수의 메모리 주소를 최대 8의 배수로 정렬한다는 뜻이 된다.
만약 패킹 크기를 4로 바꾼다면 `double`이나 `int64_t` 같은 타입들이 사용되었을 때 더 이상 정렬이 보장되지 않게 된다.  
왜 디폴트 값을 8로 정했는지 이해가 되는가?

구조체를 만들 때는 어떻게 패킹이 될지 잘 예상해서 조각을 맞추듯이 만들어야지 아무 순서로나 마구 쑤셔넣는 것은 프로답지 못하다.  
마이크로소프트에서 만든 거의 대부분의 구조체들은 [이런 사소한 것들까지 잘 고려해서](https://www.benjaminlog.com/entry/Windows-Api-reserved-parameter) 만들어져 있다.